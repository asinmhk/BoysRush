# 游戏说明

* **载入动画**：游戏开始有一段动画，动画结束后，妖精在空间左侧以**鹤翼**为阵，葫芦娃在空间右侧以**长蛇**为阵。

* **开始游戏**：在动画的任意阶段，按下**空格键**就可以开始游戏。游戏提供 **16X3** 的地图，点击**鼠标左键**可以选中当前位置的葫芦娃，**右键**可取消选中。你可以操纵葫芦娃在地图上任意移动（不合适的移动命令将不会响应）。游戏提供三个角色，分别是**大娃**（近战攻击，高护甲）、**四娃**（远程攻击，高伤害）和**五娃**（治疗能力，基本没有伤害），游戏时需要合理配置阵型，抵挡妖精的进攻。

* **游戏结束**：如果有怪物突破葫芦娃的防线，到达爷爷处（地图右侧山洞），葫芦娃保卫失败，游戏宣告结束。游戏结束后对葫芦娃的操作会被记录在 ``src/main/log.txt`` 文件中。结束后，可以选择按下**空格键**重新开始游戏，按下**L键**读取上一局**游戏记录**或者按下**R键**观看**精彩示例**。

* **测试**：利用**Junit**测试了排阵函数的正确性以及移动函数的正确性。 ``mvn clean test package`` 即可正常测试。

* **Maven**：可执行**Jar**包 ``target/Homework-1.0-SNAPSHOT.jar`` 。

# 游戏截图
![Image text](https://github.com/asinmhk/java-2017f-homework/blob/master/Fianl%20Project/%E8%A9%B9%E5%B0%8F%E9%9B%A8_151220157/screen1.jpg)![Image text](https://github.com/asinmhk/java-2017f-homework/blob/master/Fianl%20Project/%E8%A9%B9%E5%B0%8F%E9%9B%A8_151220157/screen2.jpg)

# 具体实现

## 类设计

* **Scene**：场景。场景使用**Arraylist**储存所有的生物，并且储存着一个**Map**类型的地图。在收到相应的指令后，场景可以将生物初始化到地图上，并为每一个生物创建线程解锁生物的“大脑”。

* **Block**：占位体，纯虚类。**Block**被**map**持有，地图上每一个位置都有且仅有一个**Block**。

* **RealBlock**：用作**Block**的实例化。

* **Creature**：生物，纯虚类，继承自**Block**。拥有属于自己的多种属性，可以进行移动、攻击等操作。

* **CalabashBoy、Monster**等：具体的生物类，继承自**Creature**。分别拥有不同的特性和行为函数。

* **CreatureExcuter**：生物“大脑”，持有一个生物对象。根据当前地图信息实现对持有生物的操控，包括移动、攻击等。在场景中，每个生物都有一个“大脑”作为单个线程被加入到线程池中。

* **Position**：位置，接口。用以刻画地图上的一个独立部分。

* **Position3D**：实现**Position**接口。拥有**x**、**y**、**z**三个坐标。

* **Map**：地图，接口。给出地图所需要实现的必须函数，如在指定位置放入指定**Block**或者返回相应位置的**Block**信息。

* **PlainMap**：实现**Map**接口，一类特殊的地图，由**Block**组成的数组，每个**Block**对应一个位置。当某个**Block**要移到新的位置时，需要判断新位置的合法性，在移动过程中会给该位置上锁，以防止其他**Block**线程移动到相同位置。

* **Container**：窗口类。实现图像显示。

* **Recorder**：记录生物信息。使用静态变量及函数，方便生物线程提交自己的移动及攻击信息。

## 设计原则实践

* **单一职责**： 在刚开始的时候，能够保证每个类的功能相对单一，但随着工程的复杂度不断提高，我已经无法很好的遵循单一职责原则了，如所有生物的基类**Creature**有着十分复杂的功能和实现。

* **开放封闭**： 就目前来看，工程对扩展是开放的，对修改可能···也是开放的吧。

* **里氏替换**： 在类的继承关系上，子类严格实现父类的函数，所以理论上子类的实例可以完全替代所有超类的实例。

* **接口隔离**： 接口的功能不是太单一，如**Map**接口，其实现功能比较杂乱。

* **依赖倒置**： 工程的设计基本遵循了依赖倒置原则。工程中几乎所有的依赖都依赖于抽象和接口，能够很方便的进行修改和扩展。

## 关于回放
* 从实现上来说，游戏和回放关于角色的进程实现是完全相同的，但是由于进程的随机调度，无法做到完全同步，所以角色移动时会出现会一顿一顿的情况···不过这只是显示上有问题，实际的战斗情况等是完全复制之前游戏时的数据，请见谅。
* 回放信息固定储存在 ``src\main\log.txt`` 中，每次开始游戏前清空**log**文件并在游戏结束后将记录写入。需要注意的是，游戏不结束不会写入。

## 关于移动
鼠标点击位置的判断比较粗糙，不够精确（点击区域为 **64X64** 但图像大小为 **128X128** ），所以葫芦娃有点难以指挥。并且由于地图上每个位置只能站一个生物，所以如果葫芦娃的移动路径上有其它生物，会被判定为不合适的移动指令而不予执行。

## 面向故事编程
**阅前须知：以下叙事参考自某[女神](https://github.com/SkyeWoo)（别人的故事写的真心赞！我这是强行故事）**


>古时候有一个神仙叫[貑娃](https://www.java.com)，那时候神仙是很无聊的，没有音乐，没有网络，没有游戏，过着猪一般的生活，嗯，那时候没有猪。有一天，貑娃实在是闲来无事，它用手在天地间一比划，就画出了一个**场景scene**，刚开始它很满意，终于找到乐子了啊！于是貑娃试着画出了各种形状的场景。但很快，貑娃就感觉到了厌烦，怎么办呢？它试着添加一些东西到场景中，这就有了**占位体block**。

>貑娃将占位体一个一个扔到了场景中，将它们组成有趣的图案，然后发现了一个新的问题：占位体太过散乱了，而且经常有两个占位体撞在了一起，就发生了大爆炸，这一炸，整个场景都跟着遭殃。于是它又创造了**坐标位置position**。貑娃给每个占位体都加了一个位置，同时任意两个占位体都不会有相同的位置，再将场景划分成了一个一个独立的方块，这些方块组合在一起就是**地图map**。

>貑娃把所有的占位体都移到了地图上相应的位置处，为了让占位体不站在相同位置上，它还给每个位置加了个锁，占位体被扔到地图上后就会给自己的位置上锁，当再有占位体被扔到相同位置后就会被锁给弹开。这样看着就舒心多了。

>随后，貑娃尝试着将占位体摆放成各种不同的形状，并且给一些特殊的形状起了独特的名字，比如将一堆占位体排成一长排，就叫做长蛇，将占位体斜着排成两排，就叫做鹤翼。但是占位体玩久了，貑娃又开始觉得无聊了，它想：我为什么不让这些占位体自己动呢？便在占位体的基础上创造出了**生物creature**，生物具有占位体的所有特征，除此之外，生物还拥有了生命，伤害等许多属性。生物可以移动，攻击，并且貑娃还给不同生物捏造了不同的形象，把他们分成了两个阵营，一边是葫芦娃，一边是妖精。

>为了让生物能够自己决定自己的行动，貑娃给每个生物配备了一个**大脑creatureExecuter**，大脑会决定生物的行为，有了大脑的生物们开始在地图上乱窜了，碰见不同阵营的生物还会打起架来。做完这些后，貑娃躲在一边看着场景中的生物们互相追逐打闹，这一看就是许久，它认为漫长的生命中从来没有哪一次感觉时间流逝的像现在这般迅速。

>有一天，妖精们在追着爷爷跑，这时候被在一边玩耍的葫芦娃看见了，于是纷纷上前阻挡妖精，爷爷趁乱逃进了山洞中。但是，很快貑娃就发现葫芦娃实在是太笨了，他们被妖精打的节节败退，一定是当初创造大脑的时候起了疏忽。怎么办呢？还好当初留下了“后门”。神仙毕竟是神仙，即使利用后门悄悄的帮助了葫芦娃，场上的生物也没有一个发现异常，但是在貑娃的帮助下，葫芦娃终于能够和妖精们斗个旗鼓相当了。

>貑娃觉得这次的战斗很有意思，于是将战斗的情况复制了下来，放进了一个盒子里，做成了一个游戏分享给其他的神仙一起玩。神仙们可以利用貑娃留下的后门帮助葫芦娃抵挡妖精。如果觉得打不过，貑娃还很贴心的把自己的操作留了下来，使得拿到这个游戏的神仙可以观摩学习。

>希望你玩得开心点······














